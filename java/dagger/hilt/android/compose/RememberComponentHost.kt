/*
 * Copyright (C) 2023 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dagger.hilt.android.compose

import android.content.Context
import android.content.ContextWrapper
import android.os.Handler
import android.os.Looper
import android.view.View
import androidx.activity.ComponentActivity
import androidx.compose.runtime.Composable
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.currentCompositeKeyHash
import androidx.compose.runtime.remember
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import dagger.Module
import dagger.Provides
import dagger.hilt.EntryPoint
import dagger.hilt.EntryPoints
import dagger.hilt.InstallIn
import dagger.hilt.android.compose.components.ComposeRetainedComponent
import dagger.hilt.android.compose.internal.InternalComponentHostCreator
import dagger.hilt.android.compose.scopes.ComposeRetainedScoped
import dagger.hilt.android.internal.ThreadUtil
import dagger.hilt.android.internal.lifecycle.RetainedLifecycleImpl
import java.util.ArrayDeque
import java.util.Deque

/**
 * Uses the provided [ComponentHostCreator] to create an underlying host and remembers it in the
 * composition. The host is remembered as long as [extras] is
 * [equal][ComposeComponentHostExtras.equals] to its value at the previous composition; if [extras]
 * changes, a new host will be created and remembered.
 *
 * The `ComponentHostCreator` must be generated by Hilt based on a `@ComposeComponentHost` annotated
 * class. See [the annotation][ComposeComponentHost] for details.
 *
 * When using this function with [ComposeViews][androidx.compose.ui.platform.ComposeView] manually
 * created either in XML or Kotlin, make sure to set the id of the ComposeView. Otherwise, two
 * different ComposeViews may unintentionally share dependencies from the
 * [ComposeRetainedComponent]. For example:
 * ```xml
 * # ids.xml
 * <?xml version="1.0" encoding="utf-8"?>
 * <resources>
 *   <item name="compose_view_id1" type="id"/>
 *   <item name="compose_view_id2" type="id"/>
 * </resources>
 * ```
 * ```kotlin
 * // MyActivity.kt
 * override fun onCreate(savedInstanceState: Bundle?) {
 *   super.onCreate(savedInstanceState)
 *   setContentView(
 *     LinearLayout(this).apply {
 *       addView(
 *         ComposeView(this).apply {
 *           id = R.id.compose_view_id1
 *           setContent { ... }
 *         }
 *       )
 *       addView(
 *         ComposeView(this).apply {
 *           id = R.id.compose_view_id2
 *           setContent { ... }
 *         }
 *       )
 *     }
 *   )
 * }
 * ```
 */
@Composable
fun <HostT> rememberComponentHost(
  creator: ComponentHostCreator<HostT>,
  extras: ComposeComponentHostExtras? = null
): HostT {
  require(creator is InternalComponentHostCreator) {
    "$creator should be generated to implement InternalComponentHostCreator"
  }

  val retainedComponent = rememberComposeRetainedComponent(creator, extras)

  // This double remembers the retainedComponent, but that's ok because remembering in
  // rememberComposeRetainedComponent always has a lifetime that encompasses the component host.
  return remember(extras) { creator.createComponentHost(extras, retainedComponent) }
}

/**
 * Uses the provided [InternalComponentHostCreator] to create the [ComposeRetainedComponent] and
 * remembers it such that it is retained across configuration changes. The component is remembered
 * as long as [extras] is equal to its value at the previous composition; if [extras] changes, a new
 * component will be created and remembered and the previous one will be discarded.
 */
@Composable
private fun rememberComposeRetainedComponent(
  creator: InternalComponentHostCreator<*>,
  extras: ComposeComponentHostExtras?
): ComposeRetainedComponent {
  val activity = LocalContext.current.findActivity()
  val retainedViewModel = ViewModelProvider(activity)[RetainedViewModel::class.java]
  val key = calculateComposeRetainedComponentKey(creator, extras)

  val holder =
    remember(extras) {
      object : RememberObserver {
        val component = initializeComponent()

        private fun initializeComponent(): ComposeRetainedComponent {
          val restored = retainedViewModel.restoreRetainedComponent(key)
          if (restored == null) {
            return creator.createRetainedComponent(extras)
          }

          if (restored.extras() == extras) {
            return restored
          }

          restored.composeRetainedLifecycle().dispatchOnCleared()
          return creator.createRetainedComponent(extras)
        }

        override fun onForgotten() {
          // If we are changing configuration, then the component should be saved to satisfy the
          // "retained" part of ComposeRetainedComponent. Otherwise, either we're being removed from
          // the composition and shouldn't save the retained component, or the whole composition is
          // being destroyed in which case the ViewModel will be cleared as well.
          if (activity.isChangingConfigurations) {
            retainedViewModel.storeRetainedComponent(key, component)
          } else {
            component.composeRetainedLifecycle().dispatchOnCleared()
          }
        }

        /**
         * No-op, onRemembered is used to run side effects after the RememberObserver is guaranteed
         * to be successfully remembered in the composition. No side effects are needed here.
         */
        override fun onRemembered() {}

        /**
         * Used to release resources or undo side effects in the event of failures during
         * composition.
         *
         * In practice, failures during composition mean exceptions being thrown, which will crash
         * the app. It's not likely for the app to recover in this scenario, but we call
         * dispatchOnCleared anyway to let clients cleanup any state created as a result of the
         * host/component being initialized.
         */
        override fun onAbandoned() {
          component.composeRetainedLifecycle().dispatchOnCleared()
        }
      }
    }

  return holder.component
}

/**
 * Calculates a key that is likely to be unique for the given inputs, which can be used to store the
 * [ComposeRetainedComponent].
 *
 * This function uses [currentCompositeKeyHash] to try calculating a unique hash for the current
 * place in the composition. That alone is not sufficient as it's only based on the composition and
 * doesn't include an identifier for the root ComposeView. To resolve this, we also try to include
 * the id of the ComposeView hosting this composition.
 *
 * We can't assert that an id is set on the ComposeView because the standard
 * [androidx.compose.ui.platform.setContent] extension function doesn't set an id on the ComposeView
 * it creates. SetContent doesn't have a key interference issue though because there's only one
 * ComposeView in the view hierarchy when its used.
 *
 * See the creation functions for [androidx.compose.ui.platform.DisposableSaveableStateRegistry],
 * which has this same logic to create a unique DisposableSaveableStateRegistry per ComposeView.
 */
@Composable
private fun calculateComposeRetainedComponentKey(
  creator: InternalComponentHostCreator<*>,
  extras: ComposeComponentHostExtras?
): String {
  // LocalView is configured as an AndroidComposeView whose parent is the ComposeView itself. The
  // AndroidComposeView can't have an id, but the parent ComposeView might.
  // TODO(b/284334800): LocalView.current.parent is usually a View, evaluate if that's ever not true
  val parent = LocalView.current.parent as View
  val composeViewKeyPart = parent.id

  val creatorKeyPart = creator.javaClass.name

  val extrasKeyPart = extras.hashCode()

  // Copied from rememberSaveable's MaxSupportedRadix.
  val compositionKeyPart = currentCompositeKeyHash.toString(radix = 36)

  return "${composeViewKeyPart}_${creatorKeyPart}_${extrasKeyPart}_$compositionKeyPart"
}

/** ViewModel used to retain ComposeRetainedComponents across configuration changes. */
internal class RetainedViewModel : ViewModel(), DefaultLifecycleObserver {
  private val mainThreadHandler by lazy { Handler(Looper.getMainLooper()) }
  private val cleanUpUnusedComponentsRunnable = Runnable { clearAllComponents() }
  private var needsCleanup = false

  private val keyToRetainedComponent = mutableMapOf<String, Deque<ComposeRetainedComponent>>()

  /**
   * Returns the most recently stored ComposeRetainedComponent for the given [key] if any, consuming
   * it in the process.
   */
  fun restoreRetainedComponent(key: String): ComposeRetainedComponent? {
    ThreadUtil.ensureMainThread()
    return keyToRetainedComponent[key]?.pollFirst()
  }

  /**
   * Stores the given [ComposeRetainedComponent] for the given [key].
   *
   * In the event that there's already a ComposeRetainedComponent stored for the key, the new
   * component will be stored in addition to the original. Later calls to [restoreRetainedComponent]
   * for the same key will return the ComposeRetainedComponents in **LIFO order**. This is necessary
   * and important because [rememberComposeRetainedComponent] uses a RememberObserver to store
   * retained components and [RememberObserver.onForgotten] is called in the opposite order that
   * objects are remembered.
   */
  fun storeRetainedComponent(key: String, component: ComposeRetainedComponent) {
    ThreadUtil.ensureMainThread()
    keyToRetainedComponent.getOrPut(key) { ArrayDeque() }.addFirst(component)
    needsCleanup = true
  }

  /**
   * Posts a runnable to the main thread to cleanup non-restored components.
   *
   * In normal scenarios, the onForgotten part of [rememberComposeRetainedComponent] will clean up
   * components when they're removed from the composition. However, there's an edge case where the
   * composition changes during a configuration change. When that happens, onForgotten isn't called
   * so the component doesn't have a chance to be cleaned up.
   *
   * This workaround is used to handle the edge case. It relies on the fact that recomposition
   * happens on the main thread and will complete before the posted runnable runs. After
   * recomposition completes, any components left in [keyToRetainedComponent] are no longer part of
   * the composition and should be cleaned up to avoid leaks.
   *
   * TODO: b/294901855 - Remove the workaround and use rememberRetained when it's available.
   */
  override fun onResume(owner: LifecycleOwner) {
    ThreadUtil.ensureMainThread()
    owner.lifecycle.removeObserver(this)

    if (!needsCleanup) {
      return
    }

    needsCleanup = false
    mainThreadHandler.post(cleanUpUnusedComponentsRunnable)
  }

  override fun onCleared() {
    super.onCleared()
    mainThreadHandler.removeCallbacks(cleanUpUnusedComponentsRunnable)
    clearAllComponents()
  }

  private fun clearAllComponents() {
    ThreadUtil.ensureMainThread()
    for (component in keyToRetainedComponent.values.flatten()) {
      component.composeRetainedLifecycle().dispatchOnCleared()
    }
    keyToRetainedComponent.clear()
  }
}

/**
 * Attempts to find the closest [ComponentActivity] in the Context hierarchy.
 *
 * This method looks for ComponentActivity, as opposed to another subclass, because
 * ComponentActivity is the very top of the class hierarchy that extends ViewModelStoreOwner.
 * Looking for something lower, such as FragmentActivity, could miss valid contexts for a
 * ComposeComponentHost.
 *
 * Note that this function recursively walks up the ContextWrapper hierarchy to find the
 * ComponentActivity, if it exists.
 *
 * @throws IllegalStateException if no ComponentActivity can be found.
 */
private tailrec fun Context.findActivity(): ComponentActivity =
  when (this) {
    is ComponentActivity -> this
    is ContextWrapper -> this.baseContext.findActivity()
    else ->
      throw IllegalStateException(
        "ComposeComponentHosts must be used within the context of a ComponentActivity."
      )
  }

private fun ComposeRetainedComponent.composeRetainedLifecycle(): RetainedLifecycleImpl =
  EntryPoints.get(this, ComposeRetainedComponentEntryPoint::class.java)
    .getComposeRetainedLifecycle() as RetainedLifecycleImpl

private fun ComposeRetainedComponent.extras(): ComposeComponentHostExtras? =
  EntryPoints.get(this, ComposeRetainedComponentEntryPoint::class.java).getExtras()

@EntryPoint
@InstallIn(ComposeRetainedComponent::class)
internal interface ComposeRetainedComponentEntryPoint {
  fun getComposeRetainedLifecycle(): ComposeRetainedLifecycle

  fun getExtras(): ComposeComponentHostExtras?
}

@Module
@InstallIn(ComposeRetainedComponent::class)
internal object LifecycleModule {
  @Provides
  @ComposeRetainedScoped
  fun provideComposeRetainedLifecycle(): ComposeRetainedLifecycle = RetainedLifecycleImpl()
}
